<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D飞行模拟器</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }
        canvas {
            display: block;
        }
        .ui-panel {
            position: absolute;
            color: white;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        #info {
            top: 10px;
            left: 10px;
            min-width: 200px;
        }
        #info h3 {
            margin-top: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        #controls {
            bottom: 10px;
            left: 10px;
            max-width: 250px;
        }
        .settings-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .settings-toggle:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
        #settings-panel {
            top: 10px;
            right: 10px;
            width: 250px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            cursor: help;
        }
        .slider-wrap {
            display: flex;
            align-items: center;
        }
        .slider-wrap input {
            flex: 1;
            margin-right: 8px;
        }
        .slider-wrap span {
            width: 40px;
            text-align: right;
        }
        .reset-button {
            width: 100%;
            padding: 8px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.2s ease;
        }
        .reset-button:hover {
            background-color: #d32f2f;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        @media (max-width: 768px) {
            .ui-panel {
                font-size: 12px;
                padding: 8px;
            }
            #controls {
                max-width: 180px;
            }
        }
        /* 添加加载画面 */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4CAF50;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- 加载画面 -->
    <div id="loading-screen">
        <div class="loader"></div>
        <p>正在加载游戏资源...</p>
    </div>
    
    <div id="info" class="ui-panel">
        <h3>飞行模拟器</h3>
        <p>速度: <span id="speed">0</span> km/h</p>
        <p>高度: <span id="altitude">0</span> m</p>
        <p>进度: <span id="progress">0</span>%</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
    
    <div id="controls" class="ui-panel">
        <p>控制方式:</p>
        <p>W/↑ - 向前移动</p>
        <p>S/↓ - 向后移动</p>
        <p>A/← - 向左移动</p>
        <p>D/→ - 向右移动</p>
        <p>空格 - 跳跃</p>
        <p>鼠标 - 控制视角</p>
        <p>鼠标左键 - 发射小球</p>
        <p>ESC - 退出鼠标控制</p>
        <p>点击画面 - 进入鼠标控制</p>
    </div>
    
    <button id="settings-toggle" class="settings-toggle">设置</button>
    <div id="settings-panel" class="ui-panel"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // 资源加载器和计数器
        const loadingManager = new THREE.LoadingManager();
        let resourcesLoaded = 0;
        let totalResources = 8; // 设置一个预期的资源数
        
        loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
            resourcesLoaded = itemsLoaded;
            document.querySelector('#loading-screen p').textContent = `正在加载游戏资源... ${Math.round((itemsLoaded / totalResources) * 100)}%`;
        };
        
        loadingManager.onLoad = function() {
            document.querySelector('#loading-screen p').textContent = '加载完成!';
            setTimeout(() => {
                const loadingScreen = document.getElementById('loading-screen');
                loadingScreen.style.opacity = 0;
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 200);
        };
        
        // 确保所有纹理加载器都使用这个管理器
        const textureLoader = new THREE.TextureLoader(loadingManager);
        const skyboxLoader = new THREE.CubeTextureLoader(loadingManager);
        
        // 场景设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        
        // 使用WebGL2渲染器，提高性能
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance",
            alpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比，优化性能
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 更柔和的阴影
        document.body.appendChild(renderer.domElement);

        // 光照设置
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 300, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 1000;
        directionalLight.shadow.camera.left = -500;
        directionalLight.shadow.camera.right = 500;
        directionalLight.shadow.camera.top = 500;
        directionalLight.shadow.camera.bottom = -500;
        scene.add(directionalLight);

        // 天空盒
        const skyboxTexture = skyboxLoader.load([
            'https://threejs.org/examples/textures/cube/Park2/negx.jpg',
            'https://threejs.org/examples/textures/cube/Park2/posx.jpg',
            'https://threejs.org/examples/textures/cube/Park2/negy.jpg',
            'https://threejs.org/examples/textures/cube/Park2/posy.jpg',
            'https://threejs.org/examples/textures/cube/Park2/negz.jpg',
            'https://threejs.org/examples/textures/cube/Park2/posz.jpg'
        ]);
        scene.background = skyboxTexture;
        scene.environment = skyboxTexture;

        // 创建一个函数来设置材质的反射属性
        function makeReflective(material) {
            material.envMap = skyboxTexture;
            material.envMapIntensity = 1; // 反射强度，可以调整
            material.metalness = 0.6; // 金属度，影响反射效果
            material.roughness = 0.7; // 粗糙度，值越小反射越清晰
            material.needsUpdate = true;
        }

        // 地面
        const groundSize = 10000;
        const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(groundSize / 100, groundSize / 100);
        groundTexture.anisotropy = 16;
        
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture });
        makeReflective(groundMaterial);
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // 创建山脉
        function createMountain(x, z, height, radius) {
            const mountainGeometry = new THREE.ConeGeometry(radius, height, 32);
            const mountainTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            mountainTexture.wrapS = mountainTexture.wrapT = THREE.RepeatWrapping;
            mountainTexture.repeat.set(5, 5);
            const mountainMaterial = new THREE.MeshStandardMaterial({ map: mountainTexture });
            makeReflective(mountainMaterial);
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.set(x, height / 2, z);
            mountain.castShadow = true;
            mountain.receiveShadow = true;
            scene.add(mountain);
        }

        // 创建多座山
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.8;
            const z = (Math.random() - 0.5) * groundSize * 0.8;
            const height = Math.random() * 500 + 200;
            const radius = Math.random() * 300 + 100;
            createMountain(x, z, height, radius);
        }

        // 创建云朵
        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const cloudGeometry = new THREE.SphereGeometry(50, 16, 16);
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            makeReflective(cloudMaterial);
            
            // 创建多个球体组成一朵云
            const mainSphere = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloudGroup.add(mainSphere);
            
            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(30 + Math.random() * 20, 16, 16),
                    cloudMaterial
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 70,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 70
                );
                cloudGroup.add(sphere);
            }
            
            cloudGroup.position.set(x, y, z);
            scene.add(cloudGroup);
            return cloudGroup;
        }

        // 创建多朵云
        const clouds = [];
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.8;
            const y = Math.random() * 1000 + 500;
            const z = (Math.random() - 0.5) * groundSize * 0.8;
            clouds.push(createCloud(x, y, z));
        }

        // 创建建筑物
        function createBuilding(x, z, width, height, depth) {
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
            buildingTexture.wrapS = buildingTexture.wrapT = THREE.RepeatWrapping;
            buildingTexture.repeat.set(width / 50, height / 50);
            const buildingMaterial = new THREE.MeshStandardMaterial({ map: buildingTexture });
            makeReflective(buildingMaterial);
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
        }

        // 创建城市
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            const width = Math.random() * 100 + 50;
            const height = Math.random() * 300 + 100;
            const depth = Math.random() * 100 + 50;
            createBuilding(x, z, width, height, depth);
        }

        // 创建浮空木板
        const platforms = [];
        function createPlatform(x, y, z, width, depth) {
            const platformGeometry = new THREE.BoxGeometry(width, 5, depth);
            const woodTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
            woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(2, 2);
            
            const platformMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });
            makeReflective(platformMaterial);
            platformMaterial.envMapIntensity = 0.1;
            platformMaterial.metalness = 0.3; // 降低木板金属度
            platformMaterial.roughness = 0.8; // 增加木板粗糙度
            
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            
            // 保存平台信息，用于碰撞检测
            platforms.push({
                mesh: platform,
                width: width,
                depth: depth,
                y: y
            });
            
            return platform;
        }

        // 创建跳跃路径 - 螺旋向上的路径
        const maxHeight = 6000; // 最大高度
        const platformCount = 400; // 平台数量
        const startRadius = 1000; // 起始半径
        let lastPlatformY = 100; // 第一个平台的高度

        // 创建漂浮在空中的跳跃木板路径
        for (let i = 0; i < platformCount; i++) {
            // 螺旋路径参数
            const angle = (i / platformCount) * Math.PI * 12; // 螺旋角度
            const radius = startRadius - (i / platformCount) * 300; // 半径逐渐减小
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // 高度逐渐增加，但不是均匀的
            const heightStep = 20 + Math.random() * 20; // 每个平台的高度差 (20-40之间)
            lastPlatformY += heightStep;
            
            // 平台大小随高度变化
            const platformWidth = 60 - (i / platformCount) * 20; // 高处平台更小
            const platformDepth = 60 - (i / platformCount) * 20;
            
            createPlatform(x, lastPlatformY, z, platformWidth, platformDepth);
        }

        // 添加特殊的大型平台作为休息点和检查点
        for (let i = 0; i < 8; i++) {
            const checkpointHeight = maxHeight * (i + 1) / 9;
            const angle = Math.random() * Math.PI * 2;
            const radius = startRadius * 0.5;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // 创建更大的检查点平台
            createPlatform(x, checkpointHeight, z, 200, 200);
        }

        // 在最高处添加一个最终目标平台
        createPlatform(0, maxHeight, 0, 120, 120);

        // 替换简单的小火柴人，创建更精细的角色模型
        const stickmanGroup = new THREE.Group();
        scene.add(stickmanGroup);

        // 创建更精细的头部 - 调整为更光滑的材质
        const headGeometry = new THREE.SphereGeometry(10, 32, 32);
        const headMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffcc99,
            roughness: 0.3, // 降低粗糙度使头部更光滑
            metalness: 0.1
        });
        makeReflective(headMaterial);
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 40;
        head.castShadow = true;
        stickmanGroup.add(head);

        // 创建更精细的身体
        const torsoGeometry = new THREE.CylinderGeometry(8, 10, 25, 16);
        const torsoMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3366cc,
            roughness: 0.7,
            metalness: 0.3
        });
        makeReflective(torsoMaterial);
        const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
        torso.position.y = 22;
        torso.castShadow = true;
        stickmanGroup.add(torso);

        // 肩膀
        const shoulderGeometry = new THREE.SphereGeometry(6, 16, 16);
        const shoulderMaterial = torsoMaterial;

        const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        leftShoulder.position.set(-12, 32, 0);
        leftShoulder.scale.set(0.8, 0.8, 0.8);
        stickmanGroup.add(leftShoulder);

        const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        rightShoulder.position.set(12, 32, 0);
        rightShoulder.scale.set(0.8, 0.8, 0.8);
        stickmanGroup.add(rightShoulder);

        // 创建更精细的手臂
        const armGeometry = new THREE.CylinderGeometry(3, 3, 20, 16);
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3366cc,
            roughness: 0.7,
            metalness: 0.3
        });
        makeReflective(armMaterial);

        // 手部
        const handGeometry = new THREE.SphereGeometry(3.5, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffcc99,
            roughness: 0.7,
            metalness: 0.1
        });
        makeReflective(handMaterial);

        // 左臂组
        const leftArmGroup = new THREE.Group();
        leftArmGroup.position.set(-12, 32, 0);
        stickmanGroup.add(leftArmGroup);

        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(0, -10, 0);
        leftArm.castShadow = true;
        leftArmGroup.add(leftArm);

        const leftHand = new THREE.Mesh(handGeometry, handMaterial);
        leftHand.position.set(0, -21, 0);
        leftHand.castShadow = true;
        leftArmGroup.add(leftHand);

        // 右臂组
        const rightArmGroup = new THREE.Group();
        rightArmGroup.position.set(12, 32, 0);
        stickmanGroup.add(rightArmGroup);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0, -10, 0);
        rightArm.castShadow = true;
        rightArmGroup.add(rightArm);

        const rightHand = new THREE.Mesh(handGeometry, handMaterial);
        rightHand.position.set(0, -21, 0);
        rightHand.castShadow = true;
        rightArmGroup.add(rightHand);

        // 腰部
        const waistGeometry = new THREE.CylinderGeometry(7, 7, 6, 16);
        const waistMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.7,
            metalness: 0.3
        });
        makeReflective(waistMaterial);
        const waist = new THREE.Mesh(waistGeometry, waistMaterial);
        waist.position.y = 7;
        waist.castShadow = true;
        stickmanGroup.add(waist);

        // 创建更精细的腿
        const legGeometry = new THREE.CylinderGeometry(3.5, 3.5, 20, 16);
        const legMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.7,
            metalness: 0.3
        });
        makeReflective(legMaterial);

        // 脚部
        const footGeometry = new THREE.CylinderGeometry(3.5, 5, 5, 16);
        footGeometry.translate(0, -2.5, 2); // 将脚向前偏移
        const footMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.4
        });
        makeReflective(footMaterial);

        // 左腿组
        const leftLegGroup = new THREE.Group();
        leftLegGroup.position.set(-5, 9, 0);
        stickmanGroup.add(leftLegGroup);

        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(0, -10, 0);
        leftLeg.castShadow = true;
        leftLegGroup.add(leftLeg);

        const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
        leftFoot.position.set(0, -22, 0);
        leftFoot.rotation.x = Math.PI / 12; // 略微抬起
        leftFoot.castShadow = true;
        leftLegGroup.add(leftFoot);

        // 右腿组
        const rightLegGroup = new THREE.Group();
        rightLegGroup.position.set(5, 9, 0);
        stickmanGroup.add(rightLegGroup);

        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0, -10, 0);
        rightLeg.castShadow = true;
        rightLegGroup.add(rightLeg);

        const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
        rightFoot.position.set(0, -22, 0);
        rightFoot.rotation.x = Math.PI / 12; // 略微抬起
        rightFoot.castShadow = true;
        rightLegGroup.add(rightFoot);

        // 设置小人的初始位置
        stickmanGroup.position.y = 15;

        // 设置相机位置
        camera.position.set(0, 70, 150);
        camera.lookAt(stickmanGroup.position);
        stickmanGroup.add(camera);

        // 移动控制变量
        const movementState = {
            speed: 0,
            maxSpeed: 200,
            acceleration: 1,
            deceleration: 0.5,
            rotationSpeed: 0.02,
            jumpForce: 100,
            gravity: 0.5,
            isJumping: false,
            verticalVelocity: 0,
            mouseControl: true,
            mouseSensitivity: 0.002
        };

        // 键盘控制
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });

        // 添加一个变量来跟踪指针锁定状态
        let isPointerLocked = false;

        // 修改指针锁定事件监听
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            // 根据锁定状态显示/隐藏鼠标
            if (isPointerLocked) {
                document.body.style.cursor = 'none';
            } else {
                document.body.style.cursor = 'auto';
            }
        });

        // 修改mousemove事件监听器
        document.addEventListener('mousemove', (event) => {
            if (isPointerLocked && movementState.mouseControl) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                // 水平旋转（允许360度）
                stickmanGroup.rotation.y -= movementX * movementState.mouseSensitivity;
                
                // 垂直旋转（限制在-85度到85度之间）
                const currentRotationX = camera.rotation.x;
                const newRotationX = currentRotationX - movementY * movementState.mouseSensitivity;
                // 将限制从PI/3改为85度（约1.48弧度）
                camera.rotation.x = Math.max(-1.48, Math.min(1.48, newRotationX));
            }
        });

        // 修改点击事件监听器
        renderer.domElement.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        // 更新UI信息
        function updateInfo() {
            const speedValue = Math.round(movementState.speed);
            const altitudeValue = Math.round(stickmanGroup.position.y);
            const progressValue = Math.min(100, Math.round((stickmanGroup.position.y / maxHeight) * 100));
            
            document.getElementById('speed').textContent = speedValue;
            document.getElementById('altitude').textContent = altitudeValue;
            document.getElementById('progress').textContent = progressValue;
            updateProgressBar(progressValue);
        }

        // 更新控制说明
        document.getElementById('controls').innerHTML = `
            <p>控制方式:</p>
            <p>W/↑ - 向前移动</p>
            <p>S/↓ - 向后移动</p>
            <p>A/← - 向左移动</p>
            <p>D/→ - 向右移动</p>
            <p>空格 - 跳跃</p>
            <p>鼠标 - 控制视角</p>
            <p>鼠标左键 - 发射小球</p>
            <p>ESC - 退出鼠标控制</p>
            <p>点击画面 - 进入鼠标控制</p>
        `;

        // 添加设置面板
        const settingsPanel = document.getElementById('settings-panel');
        settingsPanel.style.display = 'none'; // 默认隐藏

        // 添加设置面板标题和开关按钮
        const settingsTitle = document.createElement('div');
        settingsTitle.innerHTML = '<h3>游戏设置</h3>';
        settingsTitle.style.textAlign = 'center';
        settingsTitle.style.marginBottom = '10px';
        settingsPanel.appendChild(settingsTitle);

        // 创建设置开关按钮
        const settingsToggle = document.getElementById('settings-toggle');
        settingsToggle.addEventListener('click', function() {
            if (settingsPanel.style.display === 'none') {
                settingsPanel.style.display = 'block';
            } else {
                settingsPanel.style.display = 'none';
            }
        });

        // 为每个参数创建滑块
        function createSlider(name, min, max, step, value, label, description) {
            const container = document.createElement('div');
            container.className = 'slider-container';
            
            const labelEl = document.createElement('label');
            labelEl.textContent = label || name;
            labelEl.title = description || '';
            container.appendChild(labelEl);
            
            const sliderWrap = document.createElement('div');
            sliderWrap.className = 'slider-wrap';
            
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = min;
            slider.max = max;
            slider.step = step;
            slider.value = value;
            slider.id = `setting-${name}`;
            sliderWrap.appendChild(slider);
            
            const valueDisplay = document.createElement('span');
            valueDisplay.textContent = value;
            valueDisplay.id = `value-${name}`;
            sliderWrap.appendChild(valueDisplay);
            
            container.appendChild(sliderWrap);
            settingsPanel.appendChild(container);
            
            // 滑块改变事件
            slider.addEventListener('input', function() {
                const newValue = parseFloat(this.value);
                valueDisplay.textContent = newValue;
                movementState[name] = newValue;
            });
        }

        // 添加所有参数滑块
        createSlider('maxSpeed', 50, 500, 10, movementState.maxSpeed, '最大速度', '角色可达到的最大移动速度');
        createSlider('acceleration', 0.1, 5, 0.1, movementState.acceleration, '加速度', '按键时的加速速率');
        createSlider('deceleration', 0.1, 3, 0.1, movementState.deceleration, '减速度', '松开按键时的自然减速速率');
        createSlider('rotationSpeed', 0.005, 0.05, 0.005, movementState.rotationSpeed, '转向速度', '键盘左右转向的速度');
        createSlider('jumpForce', 50, 300, 10, movementState.jumpForce, '跳跃力量', '跳跃的高度');
        createSlider('gravity', 0.1, 2, 0.1, movementState.gravity, '重力', '下落的速度');
        createSlider('mouseSensitivity', 0.0005, 0.01, 0.0005, movementState.mouseSensitivity, '鼠标灵敏度', '鼠标视角转动的灵敏度');

        // 添加重置按钮
        const resetButton = document.createElement('button');
        resetButton.textContent = '恢复默认设置';
        resetButton.className = 'reset-button';
        resetButton.addEventListener('click', resetSettings);
        settingsPanel.appendChild(resetButton);

        // 在场景初始化后添加落地点指示器
        // 添加在创建小火柴人之前

        // 创建落地点指示器
        const landingMarker = new THREE.Mesh(
            new THREE.CircleGeometry(10, 32),
            new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide,
                depthWrite: false
            })
        );
        landingMarker.rotation.x = -Math.PI / 2; // 使圆形平躺
        landingMarker.visible = false; // 初始时隐藏
        scene.add(landingMarker);

        // 在场景初始化后添加小球相关的代码
        // 添加在创建落地点指示器之前

        // 创建小球池和物理参数
        const balls = [];
        const maxBalls = 50; // 最大同时存在的小球数量
        const ballLifetime = 18000; // 小球存在时间（毫秒）
        const ballSpeed = 200; // 小球发射速度

        // 创建小球材质
        // 创建小球纹理
        const ballTexture = textureLoader.load('https://threejs.org/examples/textures/ambientcg/Ice002_1K-JPG_Color.jpg'); // 替换为实际的纹理图片路径
        const ballNormalMap = textureLoader.load('https://threejs.org/examples/textures/ambientcg/Ice002_1K-JPG_NormalGL.jpg'); // 替换为实际的法线贴图路径
        const ballRoughnessMap = textureLoader.load('https://threejs.org/examples/textures/ambientcg/Ice002_1K-JPG_Roughness.jpg'); // 替换为实际的粗糙度贴图路径

        const ballMaterial = new THREE.MeshStandardMaterial({
            map: ballTexture,
            normalMap: ballNormalMap, 
            roughnessMap: ballRoughnessMap,
            metalness: 0.7,
            roughness: 0.3
        });
        makeReflective(ballMaterial);

        // 创建小球的函数
        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(9, 16, 16);
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            
            // 获取发射方向 - 使用相机的方向
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // 使用getWorldDirection替代getWorldQuaternion
            
            // 设置小球初始位置（从相机位置稍微往前）
            const position = new THREE.Vector3();
            position.copy(stickmanGroup.position);
            position.y += 35; // 调整为更高的位置，从30改为35
            position.add(direction.multiplyScalar(20)); // 往前一点，避免碰撞到自己
            ball.position.copy(position);
            
            // 保存小球的速度和创建时间
            ball.velocity = direction.normalize().multiplyScalar(ballSpeed);
            ball.velocity.y += 7; // 稍微向上一点
            ball.createTime = Date.now();
            
            scene.add(ball);
            balls.push(ball);
            
            // 如果超过最大数量，移除最早的小球
            if (balls.length > maxBalls) {
                const oldestBall = balls.shift();
                scene.remove(oldestBall);
            }
        }

        // 修改鼠标点击事件处理
        document.addEventListener('mousedown', (event) => {
            // 只在指针锁定状态下且是左键点击时发射小球
            if (event.button === 0 && document.pointerLockElement === renderer.domElement) {
                createBall();
            }
        });

        // 动画循环
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // 计算帧时间差，使动画基于时间而非帧率
            const delta = (time - lastTime) / 1000; // 转换为秒
            lastTime = time;
            
            // 这里使用delta来调整所有动画和运动，使其与帧率无关
            // 示例: movement * delta 而不是 movement / 60
            
            // 处理键盘输入
            if (keys['w'] || keys['arrowup']) {
                movementState.speed = movementState.maxSpeed; // 直接设置为最大速度
            } else if (keys['s'] || keys['arrowdown']) {
                movementState.speed = -movementState.maxSpeed / 2; // 直接设置为最大速度的一半（后退）
            } else {
                movementState.speed = 0; // 没有按键时立即停止
            }

            // 修改左右移动逻辑
            let sideMovement = 0;
            if (keys['d'] || keys['arrowleft']) {
                sideMovement = -movementState.maxSpeed * 0.3; // 直接设置侧向移动速度
            } else if (keys['a'] || keys['arrowright']) {
                sideMovement = movementState.maxSpeed * 0.3;
            }
            
            // 跳跃处理保持不变
            if (keys[' '] && !movementState.isJumping) {
                movementState.verticalVelocity = movementState.jumpForce;
                movementState.isJumping = true;
                
                // 跳跃动作
                leftArmGroup.rotation.x = -Math.PI / 4;
                rightArmGroup.rotation.x = -Math.PI / 4;
                leftLegGroup.rotation.x = Math.PI / 6;
                rightLegGroup.rotation.x = Math.PI / 6;
            }

            // 限制速度
            movementState.speed = Math.min(movementState.speed, movementState.maxSpeed);
            movementState.speed = Math.max(movementState.speed, -movementState.maxSpeed / 2);

            // 计算前进方向
            const forwardDirection = new THREE.Vector3(0, 0, -1);
            forwardDirection.applyQuaternion(stickmanGroup.quaternion);
            forwardDirection.normalize();
            
            // 计算侧向方向（与前进方向垂直）
            const sideDirection = new THREE.Vector3(-1, 0, 0);
            sideDirection.applyQuaternion(stickmanGroup.quaternion);
            sideDirection.normalize();
            
            // 应用前进移动
            stickmanGroup.position.x += forwardDirection.x * movementState.speed / 60;
            stickmanGroup.position.z += forwardDirection.z * movementState.speed / 60;
            
            // 应用侧向移动
            stickmanGroup.position.x += sideDirection.x * sideMovement / 60;
            stickmanGroup.position.z += sideDirection.z * sideMovement / 60;

            // 应用重力和跳跃
            movementState.verticalVelocity -= movementState.gravity;
            stickmanGroup.position.y += movementState.verticalVelocity / 10;

            // 地面检测
            if (stickmanGroup.position.y < 15) {
                stickmanGroup.position.y = 15;
                movementState.verticalVelocity = 0;
                movementState.isJumping = false;
            }
            
            // 修改平台碰撞检测部分
            if (movementState.verticalVelocity < 0) {
                const stickmanPosition = stickmanGroup.position.clone();
                const stickmanFeet = stickmanPosition.y - 15; // 调整脚部位置计算，从12.5改为15
                const stickmanRadius = 10; // 小人碰撞半径
                
                for (const platform of platforms) {
                    const platformTop = platform.y + 2.5; // 平台顶部
                    const platformBottom = platform.y - 2.5; // 平台底部
                    
                    // 扩大检测范围，增加一个缓冲区
                    if (stickmanFeet <= platformTop + 5 && stickmanFeet >= platformTop - 10) {
                        // 获取平台的宽度和深度一半，增加一点碰撞余量
                        const halfWidth = platform.width / 2 + stickmanRadius;
                        const halfDepth = platform.depth / 2 + stickmanRadius;
                        
                        // 获取平台位置
                        const platformPosition = platform.mesh.position;
                        
                        // 使用更精确的碰撞检测
                        const distanceX = Math.abs(stickmanPosition.x - platformPosition.x);
                        const distanceZ = Math.abs(stickmanPosition.z - platformPosition.z);
                        
                        if (distanceX <= halfWidth && distanceZ <= halfDepth) {
                            // 确保玩家确实在平台上方
                            if (stickmanFeet > platformTop - 5) {
                                // 碰撞到平台，将小人放在平台上
                                stickmanGroup.position.y = platformTop + 15; // 从12.5修改为15
                                movementState.verticalVelocity = 0;
                                movementState.isJumping = false;
                                
                                // 添加一点"吸附"效果，防止轻微的滑落
                                if (Math.abs(movementState.verticalVelocity) < 2) {
                                    movementState.verticalVelocity = 0;
                                }
                                break;
                            }
                        }
                    }
                }
            }

            // 腿部动画
            if (!movementState.isJumping) {
                if (Math.abs(movementState.speed) > 5) {
                    // 行走动画
                    const walkCycle = Date.now() % 1000 / 500 * Math.PI;
                    
                    // 腿部摆动
                    leftLegGroup.rotation.x = Math.sin(walkCycle) * 0.5;
                    rightLegGroup.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
                    
                    // 手臂摆动
                    leftArmGroup.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
                    rightArmGroup.rotation.x = Math.sin(walkCycle) * 0.5;
                    
                    // 身体轻微上下移动
                    torso.position.y = 22 + Math.abs(Math.sin(walkCycle)) * 0.7;
                    head.position.y = 40 + Math.abs(Math.sin(walkCycle)) * 0.7;
                } else {
                    // 站立姿势
                    leftLegGroup.rotation.x = 0;
                    rightLegGroup.rotation.x = 0;
                    leftArmGroup.rotation.x = 0;
                    rightArmGroup.rotation.x = 0;
                    torso.position.y = 22;
                    head.position.y = 40;
                }
            } else {
                // 跳跃过程中的动画
                const jumpProgress = Math.max(0, Math.min(1, movementState.verticalVelocity / movementState.jumpForce));
                
                if (movementState.verticalVelocity > 0) {
                    // 上升阶段 - 手臂上举，腿部弯曲
                    leftArmGroup.rotation.x = -Math.PI / 4 * jumpProgress;
                    rightArmGroup.rotation.x = -Math.PI / 4 * jumpProgress;
                    leftLegGroup.rotation.x = Math.PI / 6 * jumpProgress;
                    rightLegGroup.rotation.x = Math.PI / 6 * jumpProgress;
                } else {
                    // 下降阶段 - 手臂前伸，腿部伸直准备着陆
                    leftArmGroup.rotation.x = Math.PI / 6;
                    rightArmGroup.rotation.x = Math.PI / 6;
                    leftLegGroup.rotation.x = -Math.PI / 8;
                    rightLegGroup.rotation.x = -Math.PI / 8;
                }
            }

            // 更新落地点指示器
            const raycaster = new THREE.Raycaster();
            if (movementState.isJumping) {
                // 从小人位置向下发射射线
                const origin = stickmanGroup.position.clone();
                const direction = new THREE.Vector3(0, -1, 0);
                raycaster.set(origin, direction);
                
                // 检测与地面和平台的相交
                const intersectObjects = [ground];
                platforms.forEach(platform => intersectObjects.push(platform.mesh));
                const intersects = raycaster.intersectObjects(intersectObjects);
                
                if (intersects.length > 0) {
                    // 找到最近的交点
                    const point = intersects[0].point;
                    
                    // 更新标记位置
                    landingMarker.position.set(point.x, point.y + 0.1, point.z); // 略微上移以避免z-fighting
                    
                    // 根据高度调整标记大小和透明度
                    const distance = origin.y - point.y;
                    const scale = Math.min(1 + distance / 100, 3); // 随距离增大而增大，但有上限
                    landingMarker.scale.set(scale, scale, scale);
                    
                    // 距离越远越透明
                    landingMarker.material.opacity = Math.max(0.1, 0.4 - distance / 1000);
                    
                    landingMarker.visible = true;
                } else {
                    landingMarker.visible = false;
                }
            } else {
                landingMarker.visible = false;
            }

            // 更新小球
            const gravity = new THREE.Vector3(0, -1, 0); // 小球重力
            const now = Date.now();

            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                
                // 更新位置
                ball.position.add(ball.velocity.clone().multiplyScalar(1/40));
                ball.velocity.add(gravity);
                
                // 检查地面碰撞
                if (ball.position.y < 9) { // 小球半径
                    ball.position.y = 9;
                    ball.velocity.y = -ball.velocity.y * 0.6; // 反弹，损失一些能量
                    ball.velocity.x *= 0.8; // 水平方向摩擦
                    ball.velocity.z *= 0.8;
                }
                
                // 检查与平台的碰撞
                for (const platform of platforms) {
                    const platformY = platform.y;
                    const halfWidth = platform.width / 2;
                    const halfDepth = platform.depth / 2;
                    const platformPos = platform.mesh.position;
                    
                    if (ball.position.y - 3 <= platformY + 2.5 && // 小球底部低于平台顶部
                        ball.position.y + 3 >= platformY - 2.5 && // 小球顶部高于平台底部
                        ball.position.x >= platformPos.x - halfWidth &&
                        ball.position.x <= platformPos.x + halfWidth &&
                        ball.position.z >= platformPos.z - halfDepth &&
                        ball.position.z <= platformPos.z + halfDepth) {
                        
                        // 简单的碰撞响应
                        ball.position.y = platformY + 5.5;
                        ball.velocity.y = -ball.velocity.y * 0.6;
                        ball.velocity.x *= 0.8;
                        ball.velocity.z *= 0.8;
                    }
                }
                
                // 检查生命周期
                if (now - ball.createTime > ballLifetime) {
                    scene.remove(ball);
                    balls.splice(i, 1);
                }
            }

            // 更新UI
            updateInfo();
            
            // 渲染场景
            renderer.render(scene, camera);
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        window.addEventListener('resize', onWindowResize);

        // 开始动画循环
        animate(0);

        // 更新进度条
        function updateProgressBar(percentage) {
            const progressFill = document.getElementById('progress-fill');
            progressFill.style.width = `${percentage}%`;
        }

        // 重置设置
        function resetSettings() {
            // 恢复默认值
            movementState.maxSpeed = 200;
            movementState.acceleration = 1;
            movementState.deceleration = 0.5;
            movementState.rotationSpeed = 0.02;
            movementState.jumpForce = 100;
            movementState.gravity = 0.5;
            movementState.mouseSensitivity = 0.002;
            
            // 更新UI滑块
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                const name = slider.id.replace('setting-', '');
                if (movementState[name] !== undefined) {
                    slider.value = movementState[name];
                    document.getElementById(`value-${name}`).textContent = movementState[name];
                }
            });
        }

        // 添加一个手动结束加载的计时器，以防资源加载不完成
        setTimeout(() => {
            if (document.getElementById('loading-screen').style.display !== 'none') {
                loadingManager.onLoad();
            }
        }, 5000); // 5秒后强制隐藏加载画面
    </script>
</body>
</html>
